
📦 Project Structure of: e:\MyProjects\student_performance

📄 .env
📄 .gitignore
📄 Dockerfile
📄 app.py
📁 artifacts/
    📁 2025_06_13T00_11_29Z/
        📁 data_ingestion/
            📁 ingested_data/
                📄 ingested_data.csv
            📁 raw_data/
                📄 raw.csv
        📁 data_validation/
            📁 reports/
                📄 categorical_report.yaml
                📄 drift_report.yaml
                📄 duplicates_report.yaml
                📄 missing_values_report.yaml
                📄 validation_report.yaml
            📁 validated/
                📄 validated_data.csv
    📁 2025_06_13T15_34_59Z/
        📁 data_ingestion/
            📁 ingested_data/
                📄 ingested_data.csv
            📁 raw_data/
                📄 raw.csv
        📁 data_validation/
            📁 reports/
                📄 categorical_report.yaml
                📄 drift_report.yaml
                📄 duplicates_report.yaml
                📄 missing_values_report.yaml
                📄 validation_report.yaml
            📁 validated/
                📄 validated_data.csv
    📁 2025_06_13T15_42_39Z/
        📁 data_ingestion/
            📁 ingested_data/
                📄 ingested_data.csv
            📁 raw_data/
                📄 raw.csv
        📁 data_validation/
            📁 reports/
                📄 categorical_report.yaml
                📄 drift_report.yaml
                📄 duplicates_report.yaml
                📄 missing_values_report.yaml
                📄 validation_report.yaml
            📁 validated/
                📄 validated_data.csv
    📁 2025_06_13T15_48_16Z/
        📁 data_ingestion/
            📁 ingested_data/
                📄 ingested_data.csv
            📁 raw_data/
                📄 raw.csv
        📁 data_validation/
            📁 reports/
                📄 categorical_report.yaml
                📄 drift_report.yaml
                📄 duplicates_report.yaml
                📄 missing_values_report.yaml
                📄 validation_report.yaml
            📁 validated/
                📄 validated_data.csv
    📁 2025_06_13T15_49_44Z/
        📁 data_ingestion/
            📁 ingested_data/
                📄 ingested_data.csv
            📁 raw_data/
                📄 raw.csv
        📁 data_validation/
            📁 reports/
                📄 categorical_report.yaml
                📄 drift_report.yaml
                📄 duplicates_report.yaml
                📄 missing_values_report.yaml
                📄 validation_report.yaml
            📁 validated/
                📄 validated_data.csv
    📁 2025_06_13T15_50_23Z/
        📁 data_ingestion/
            📁 ingested_data/
                📄 ingested_data.csv
            📁 raw_data/
                📄 raw.csv
        📁 data_validation/
            📁 reports/
                📄 categorical_report.yaml
                📄 drift_report.yaml
                📄 duplicates_report.yaml
                📄 missing_values_report.yaml
                📄 validation_report.yaml
            📁 validated/
                📄 validated_data.csv
    📁 2025_06_13T15_52_14Z/
        📁 data_ingestion/
            📁 ingested_data/
                📄 ingested_data.csv
            📁 raw_data/
                📄 raw.csv
        📁 data_validation/
            📁 reports/
                📄 categorical_report.yaml
                📄 drift_report.yaml
                📄 duplicates_report.yaml
                📄 missing_values_report.yaml
                📄 validation_report.yaml
            📁 validated/
                📄 validated_data.csv
    📁 2025_06_13T15_54_26Z/
        📁 data_ingestion/
            📁 ingested_data/
                📄 ingested_data.csv
            📁 raw_data/
                📄 raw.csv
        📁 data_validation/
            📁 reports/
                📄 categorical_report.yaml
                📄 drift_report.yaml
                📄 duplicates_report.yaml
                📄 missing_values_report.yaml
                📄 validation_report.yaml
            📁 validated/
                📄 validated_data.csv
    📁 2025_06_13T15_55_30Z/
        📁 data_ingestion/
            📁 ingested_data/
                📄 ingested_data.csv
            📁 raw_data/
                📄 raw.csv
        📁 data_transformation/
        📁 data_validation/
            📁 reports/
                📄 categorical_report.yaml
                📄 drift_report.yaml
                📄 duplicates_report.yaml
                📄 missing_values_report.yaml
                📄 validation_report.yaml
            📁 validated/
                📄 validated_data.csv
    📁 2025_06_13T15_56_13Z/
        📁 data_ingestion/
            📁 ingested_data/
                📄 ingested_data.csv
            📁 raw_data/
                📄 raw.csv
        📁 data_transformation/
        📁 data_validation/
            📁 reports/
                📄 categorical_report.yaml
                📄 drift_report.yaml
                📄 duplicates_report.yaml
                📄 missing_values_report.yaml
                📄 validation_report.yaml
            📁 validated/
                📄 validated_data.csv
    📁 2025_06_13T15_56_30Z/
        📁 data_ingestion/
            📁 ingested_data/
                📄 ingested_data.csv
            📁 raw_data/
                📄 raw.csv
        📁 data_transformation/
            📄 x_preprocessor.joblib
            📄 y_preprocessor.joblib
        📁 data_validation/
            📁 reports/
                📄 categorical_report.yaml
                📄 drift_report.yaml
                📄 duplicates_report.yaml
                📄 missing_values_report.yaml
                📄 validation_report.yaml
            📁 validated/
                📄 validated_data.csv
📁 config/
    📄 config.yaml
    📄 params.yaml
    📄 schema.yaml
    📄 templates.yaml
📁 data/
    📁 raw/
        📄 raw.csv
    📁 validated/
        📄 validated_data.csv
📄 debug.py
📁 logs/
    📁 2025_06_13T00_11_29Z/
        📄 2025_06_13T00_11_29Z.log
    📁 2025_06_13T15_34_59Z/
        📄 2025_06_13T15_34_59Z.log
    📁 2025_06_13T15_42_39Z/
        📄 2025_06_13T15_42_39Z.log
    📁 2025_06_13T15_48_16Z/
        📄 2025_06_13T15_48_16Z.log
    📁 2025_06_13T15_49_44Z/
        📄 2025_06_13T15_49_44Z.log
    📁 2025_06_13T15_50_23Z/
        📄 2025_06_13T15_50_23Z.log
    📁 2025_06_13T15_52_14Z/
        📄 2025_06_13T15_52_14Z.log
    📁 2025_06_13T15_54_26Z/
        📄 2025_06_13T15_54_26Z.log
    📁 2025_06_13T15_55_30Z/
        📄 2025_06_13T15_55_30Z.log
    📁 2025_06_13T15_56_13Z/
        📄 2025_06_13T15_56_13Z.log
    📁 2025_06_13T15_56_30Z/
        📄 2025_06_13T15_56_30Z.log
📄 main.py
📁 notebook/
    📄 research.ipynb
📄 project_code_dump_index.txt
📄 project_code_dump_part1.txt
📄 project_code_dump_part2.txt
📄 project_code_dump_part3.txt
📄 project_dump.py
📄 project_template.py
📄 requirements.txt
📁 research/
    📄 research.ipynb
📄 setup.py
📁 src/
    📁 student_performance/
        📄 __init__.py
        📁 components/
            📄 __init__.py
            📄 data_ingestion.py
            📄 data_transformation.py
            📄 data_validation.py
        📁 config/
            📄 __init__.py
            📄 configuration.py
        📁 constants/
            📄 __init__.py
            📄 constants.py
        📁 data_processors/
            📄 __init__.py
            📄 column_math_factory.py
            📄 encoder_factory.py
            📄 imputer_factory.py
            📄 preprocessor_builder.py
            📄 scaler_factory.py
        📁 dbhandler/
            📄 __init__.py
            📄 base_handler.py
            📄 postgres_dbhandler.py
        📁 entity/
            📄 __init__.py
            📄 artifact_entity.py
            📄 config_entity.py
        📁 exception/
            📄 __init__.py
            📄 exception.py
        📁 logging/
            📄 __init__.py
            📄 app_logger.py
        📁 pipeline/
            📄 __init__.py
            📄 training_pipeline.py
        📁 utils/
            📄 __init__.py
            📄 core.py
            📄 timestamp.py
📁 student_data/
    📄 stud.csv
📁 templates/
    📄 index.html

--- CODE DUMP | PART 2 of 3 ---


================================================================================
# PY FILE: src\student_performance\constants\constants.py
================================================================================

CONFIG_ROOT = "config"
CONFIG_FILENAME = "config.yaml"
PARAMS_FILENAME = "params.yaml"
SCHEMA_FILENAME = "schema.yaml"
TEMPLATES_FILENAME = "templates.yaml"

LOGS_ROOT = "logs"

ARTIFACTS_ROOT = "artifacts"

POSTGRES_HANDLER_ROOT = "mongo_handler"
INGEST_ROOT = "data_ingestion"
INGEST_RAW_SUBDIR = "raw_data"
INGEST_INGESTED_SUBDIR = "ingested_data"

DVC_ROOT = "data"
DVC_RAW_SUBDIR = "raw"
DVC_VALIDATED_SUBDIR = "validated"
DVC_TRANSFORMED_SUBDIR = "transformed"

VALID_ROOT = "data_validation"
VALID_VALIDATED_SUBDIR = "validated"
VALID_REPORTS_SUBDIR = "reports"

X_TRAIN_LABEL = "X_train"
Y_TRAIN_LABEL = "y_train"
X_VAL_LABEL = "X_val"
Y_VAL_LABEL = "y_val"
X_TEST_LABEL = "X_test"
Y_TEST_LABEL = "y_test"

================================================================================
# PY FILE: src\student_performance\data_processors\__init__.py
================================================================================



================================================================================
# PY FILE: src\student_performance\data_processors\column_math_factory.py
================================================================================

from typing import Literal
import pandas as pd
import numpy as np
from sklearn.base import BaseEstimator, TransformerMixin
from ensure import ensure_annotations

from src.student_performance.exception.exception import StudentPerformanceError
from src.student_performance.logging import logger


ColumnMathOperation = Literal[
    "add", "subtract", "multiply", "divide",
    "mean_of_columns", "sqrt", "square", "power",
]


class ColumnMathFactory(BaseEstimator, TransformerMixin):
    """
    Transformer to apply mathematical operations to specified columns
    and create a new output column.
    """

    def __init__(
        self,
        columns: list[str],
        operation: ColumnMathOperation,
        output_column: str,
    ) -> None:
        self.columns = columns
        self.operation = operation.lower()
        self.output_column = output_column

    def fit(self, X: pd.DataFrame, y: pd.Series = None) -> "ColumnMathFactory":
        return self

    def transform(self, X: pd.DataFrame) -> pd.DataFrame:
        try:
            df = X.copy()

            if self.operation == "add":
                df[self.output_column] = df[self.columns].sum(axis=1)

            elif self.operation == "subtract":
                df[self.output_column] = df[self.columns[0]]
                for col in self.columns[1:]:
                    df[self.output_column] -= df[col]

            elif self.operation == "multiply":
                df[self.output_column] = df[self.columns].prod(axis=1)

            elif self.operation == "divide":
                df[self.output_column] = df[self.columns[0]]
                for col in self.columns[1:]:
                    df[self.output_column] /= df[col]

            elif self.operation == "mean_of_columns":
                df[self.output_column] = df[self.columns].mean(axis=1)

            else:
                raise ValueError(f"Unsupported operation: {self.operation}")

            logger.info(
                "Applied '%s' operation on columns: %s → '%s'",
                self.operation,
                self.columns,
                self.output_column
            )

            return df

        except Exception as e:
            raise StudentPerformanceError(e, logger) from e

================================================================================
# PY FILE: src\student_performance\data_processors\encoder_factory.py
================================================================================

from typing import Optional
from ensure import ensure_annotations
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder, OrdinalEncoder

from src.student_performance.exception.exception import StudentPerformanceError
from src.student_performance.logging import logger


class EncoderFactory:
    """
    Factory to build encoding pipelines for categorical features.
    """

    _SUPPORTED_METHODS = {
        "one_hot": OneHotEncoder,
        "ordinal": OrdinalEncoder,
    }

    @staticmethod
    @ensure_annotations
    def get_encoder_pipeline(
        method: str,
        params: Optional[dict] = None,
        is_target: bool = False,
    ) -> Pipeline:
        try:
            if method not in EncoderFactory._SUPPORTED_METHODS:
                raise ValueError(f"Unsupported encoding method: {method}")

            encoder_class = EncoderFactory._SUPPORTED_METHODS[method]
            encoder = encoder_class(**(params or {}))
            return Pipeline(steps=[("encoder", encoder)])

        except Exception as e:
            raise StudentPerformanceError(e, logger) from e

================================================================================
# PY FILE: src\student_performance\data_processors\imputer_factory.py
================================================================================

from typing import Optional
from ensure import ensure_annotations
from sklearn.pipeline import Pipeline
from sklearn.impute import KNNImputer, SimpleImputer
# explicitly require this experimental feature
from sklearn.experimental import enable_iterative_imputer  # noqa
# now you can import normally from impute
from sklearn.impute import IterativeImputer

from src.student_performance.exception.exception import StudentPerformanceError
from src.student_performance.logging import logger


class ImputerFactory:
    """
    Factory to build imputation pipelines for numerical data.
    """

    _SUPPORTED_METHODS = {
        "knn": KNNImputer,
        "simple": SimpleImputer,
        "iterative": IterativeImputer,
    }

    @staticmethod
    @ensure_annotations
    def get_imputer_pipeline(
        method: str,
        params: Optional[dict] = None,
        is_target: bool = False
    ) -> Pipeline:
        try:
            if method == "custom":
                if not params or "custom_callable" not in params:
                    raise ValueError("Custom imputer requires a 'custom_callable' in params.")
                imputer = params["custom_callable"]()
            else:
                ImputerClass = ImputerFactory._SUPPORTED_METHODS.get(method)
                if not ImputerClass:
                    raise ValueError(f"Unsupported imputation method: {method}")
                imputer = ImputerClass(**(params or {}))

            return Pipeline(steps=[("imputer", imputer)])

        except Exception as e:
            raise StudentPerformanceError(e, logger) from e

================================================================================
# PY FILE: src\student_performance\data_processors\preprocessor_builder.py
================================================================================

from typing import Optional, Dict, Tuple
from sklearn.pipeline import Pipeline
from box import ConfigBox

from src.student_performance.data_processors.imputer_factory import ImputerFactory
from src.student_performance.data_processors.scaler_factory import ScalerFactory
from src.student_performance.data_processors.encoder_factory import EncoderFactory
from src.student_performance.data_processors.column_math_factory import ColumnMathFactory
from src.student_performance.exception.exception import StudentPerformanceError
from src.student_performance.logging import logger


class PreprocessorBuilder:
    """
    Dynamically builds X and Y preprocessing pipelines using configurable steps and methods.

    Supported YAML step keys:
        - imputation      → knn, simple, iterative (via ImputerFactory)
        - standardization → standard_scaler, minmax_scaler, robust_scaler (via ScalerFactory)
        - encoding        → one_hot, ordinal (via EncoderFactory)
        - column_math     → mean, add, power, etc. (via ColumnMathFactory)
    """

    @staticmethod
    def _build_column_math(method: str, params: Dict):
        try:
            return ColumnMathFactory(
                columns=params["input_column"],
                operation=method,
                output_column=params["output_column"],
            )
        except KeyError as e:
            raise ValueError(f"Missing required parameter for column_math: {e}") from e

    STEP_BUILDERS = {
        "imputation": ImputerFactory.get_imputer_pipeline,
        "standardization": ScalerFactory.get_scaler_pipeline,
        "encoding": EncoderFactory.get_encoder_pipeline,
        "column_math": _build_column_math.__func__,
    }

    def __init__(self, steps: Optional[Dict] = None, methods: Optional[Dict] = None) -> None:
        """
        Args:
            steps (Dict): Ordered step names per section (e.g., {"x": ["imputation", "encoding"]})
            methods (Dict): Method config per section (e.g., {"x": {"imputation": {...}}})
        """
        self.steps = steps or {}
        self.methods = methods or {}

    def _build_pipeline(self, section: str) -> Pipeline:
        """
        Build a scikit-learn pipeline for a given section ("x" or "y").

        Args:
            section (str): Section name ('x' or 'y')

        Returns:
            Pipeline: A scikit-learn Pipeline object
        """
        try:
            pipeline_steps = []
            step_list = self.steps.get(section, [])
            section_methods = self.methods.get(section, {})

            for step_name in step_list:
                step_config = section_methods.get(step_name, {})

                # Skip if explicitly set to "none"
                if not step_config or (
                    isinstance(step_config, str) and step_config.lower() == "none"
                ):
                    logger.info(
                        f"Skipping '{step_name}' step in section '{section}' as it is set to 'none'."
                    )
                    continue

                builder_fn = self.STEP_BUILDERS.get(step_name)
                if not builder_fn:
                    raise ValueError(f"Unsupported preprocessing step: '{step_name}'")

                if isinstance(step_config, (dict, ConfigBox)):
                    method_name = step_config.get("method")
                    step_params = {k: v for k, v in step_config.items() if k != "method"}
                else:
                    method_name = step_config
                    step_params = {}

                step_object = builder_fn(method_name, step_params)
                pipeline_steps.append((step_name, step_object))

            return Pipeline(pipeline_steps)

        except Exception as e:
            raise StudentPerformanceError(e, logger) from e

    def build(self) -> Tuple[Pipeline, Optional[Pipeline]]:
        """
        Builds preprocessing pipelines for both features (X) and target (Y).

        Returns:
            Tuple[Pipeline, Optional[Pipeline]]: Tuple containing x_pipeline and y_pipeline
        """
        try:
            x_pipeline = self._build_pipeline("x")
            y_pipeline = self._build_pipeline("y")
            return x_pipeline, y_pipeline
        except Exception as e:
            raise StudentPerformanceError(e, logger) from e

================================================================================
# PY FILE: src\student_performance\data_processors\scaler_factory.py
================================================================================

from typing import Optional
from ensure import ensure_annotations
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler, MinMaxScaler, RobustScaler

from src.student_performance.exception.exception import StudentPerformanceError
from src.student_performance.logging import logger


class ScalerFactory:
    """
    Factory to build scaling pipelines for numerical features.
    """

    _SUPPORTED_METHODS = {
        "standard_scaler": StandardScaler,
        "minmax": MinMaxScaler,
        "robust": RobustScaler,
    }

    @staticmethod
    @ensure_annotations
    def get_scaler_pipeline(
        method: str,
        params: Optional[dict] = None,
        is_target: bool = False
    ) -> Pipeline:
        try:
            if method not in ScalerFactory._SUPPORTED_METHODS:
                raise ValueError(f"Unsupported scaler method: {method}")

            scaler_cls = ScalerFactory._SUPPORTED_METHODS[method]
            scaler = scaler_cls(**(params or {}))

            return Pipeline(steps=[("scaler", scaler)])

        except Exception as e:
            raise StudentPerformanceError(e, logger) from e

================================================================================
# PY FILE: src\student_performance\dbhandler\__init__.py
================================================================================



================================================================================
# PY FILE: src\student_performance\dbhandler\base_handler.py
================================================================================

from abc import ABC, abstractmethod
from pathlib import Path
import pandas as pd

from src.student_performance.exception.exception import StudentPerformanceError
from src.student_performance.logging import logger


class DBHandler(ABC):
    """
    Abstract base class for all database/storage handlers.
    Enables unified behavior across PostgreSQL, MongoDB, CSV, etc.
    """

    def __enter__(self) -> "DBHandler":
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        try:
            self.close()
        except Exception as e:
            msg = "Error closing DBHandler."
            raise StudentPerformanceError(e, msg) from e

    @abstractmethod
    def close(self) -> None:
        pass

    @abstractmethod
    def load_from_source(self) -> pd.DataFrame:
        pass

    def load_from_csv(self, source: Path) -> pd.DataFrame:
        try:
            df = pd.read_csv(source)
            logger.info(f"DataFrame loaded from CSV: {source}")
            return df
        except Exception as e:
            msg = f"Failed to load DataFrame from CSV: '{source}'"
            raise StudentPerformanceError(e, msg) from e

================================================================================
# PY FILE: src\student_performance\dbhandler\postgres_dbhandler.py
================================================================================

import psycopg2
from psycopg2 import sql
import pandas as pd

from src.student_performance.exception.exception import StudentPerformanceError
from src.student_performance.logging import logger
from src.student_performance.dbhandler.base_handler import DBHandler
from src.student_performance.entity.config_entity import PostgresDBHandlerConfig
from box import ConfigBox


class PostgresDBHandler(DBHandler):
    def __init__(self, postgres_config: PostgresDBHandlerConfig) -> None:
        logger.info("Initializing PostgresDBHandler")
        self.postgres_config = postgres_config
        self._connection: psycopg2.extensions.connection | None = None
        self._cursor: psycopg2.extensions.cursor | None = None

    def _connect(self) -> None:
        logger.info("Attempting to connect to PostgreSQL")
        if not self._connection or self._connection.closed:
            try:
                self._connection = psycopg2.connect(
                    host=self.postgres_config.host,
                    port=self.postgres_config.port,
                    dbname=self.postgres_config.dbname,
                    user=self.postgres_config.user,
                    password=self.postgres_config.password,
                )
                self._cursor = self._connection.cursor()
                logger.info("Successfully connected to PostgreSQL")
            except Exception as e:
                msg = "Failed to establish PostgreSQL connection"
                raise StudentPerformanceError(e, msg) from e

    def close(self) -> None:
        if self._cursor:
            self._cursor.close()
        if self._connection:
            self._connection.close()
            logger.info("PostgreSQL connection closed")

    def ping(self) -> None:
        logger.info("Pinging PostgreSQL")
        try:
            self._connect()
            logger.info("Executing ping query")
            self._cursor.execute("SELECT 1;")
            self._cursor.fetchone()
            logger.info("PostgreSQL connection successful (ping passed).")
        except Exception as e:
            msg = "PostgreSQL ping failed"
            raise StudentPerformanceError(e, msg) from e
        logger.info("PostgreSQL ping completed")

    def load_from_source(self) -> pd.DataFrame:
        logger.info(f"Loading data from PostgreSQL table: {self.postgres_config.table_name}")
        try:
            self._connect()
            query = sql.SQL("SELECT * FROM {}").format(sql.Identifier(self.postgres_config.table_name))
            logger.info(f"Executing query: {query.as_string(self._connection)}")
            df = pd.read_sql_query(query.as_string(self._connection), self._connection)
            logger.info(f"DataFrame loaded from PostgreSQL table: {self.postgres_config.table_name}")
            return df
        except Exception as e:
            msg = f"Failed to load data from PostgreSQL table: {self.postgres_config.table_name}"
            raise StudentPerformanceError(e, msg) from e

    def get_table_list(self) -> list[str]:
        """
        Get a list of all tables in the PostgreSQL database.

        Returns:
            list[str]: A list of table names.

        Raises:
            StudentPerformanceError: If listing tables fails.
        """
        logger.info("Retrieving list of tables")
        try:
            self._connect()
            query = sql.SQL("""
                SELECT table_name
                FROM information_schema.tables
                WHERE table_schema = 'public'
                AND table_type = 'BASE TABLE';
            """)
            logger.info(f"Executing query: {query.as_string(self._connection)}")
            self._cursor.execute(query)
            tables = [table[0] for table in self._cursor.fetchall()]
            logger.info("Successfully retrieved list of tables.")
            return tables
        except Exception as e:
            msg = "Failed to retrieve list of tables"
            raise StudentPerformanceError(e, msg) from e

    def create_table_from_schema(self) -> None:
        """
        Create a PostgreSQL table if it doesn't exist using schema from ConfigBox.

        Args:
            table_name (str): The name of the table to create.
            schema (ConfigBox): Parsed schema.yaml with dot-access support.

        Raises:
            StudentPerformanceError: If table creation fails.
        """
        logger.info(f"Creating table from schema: {self.postgres_config.table_name}")
        try:
            self._connect()

            table_name = self.postgres_config.table_name

            # Check if table exists
            query = sql.SQL("""
                SELECT EXISTS (
                    SELECT 1
                    FROM information_schema.tables
                    WHERE table_name = {}
                );
            """).format(sql.Literal(table_name))
            logger.info(f"Executing query: {query.as_string(self._connection)}")
            self._cursor.execute(query)
            table_exists = self._cursor.fetchone()[0]

            if table_exists:
                logger.info(f"Table '{table_name}' already exists.")
                return

            # Access columns via dot-notation
            table_schema = self.postgres_config.table_schema[table_name].columns

            column_definitions = []

            for col_name, col_def in table_schema.items():
                col_type = col_def.type
                constraints = col_def.get("constraints", {})

                column_sql = f"{col_name} {col_type}"

                # ENUM-style value check
                if "allowed_values" in constraints:
                    allowed = ", ".join("'{}'".format(val.replace("'", "''")) for val in constraints.allowed_values)
                    column_sql += f" CHECK ({col_name} IN ({allowed}))"

                # Numeric bounds
                if "min" in constraints and "max" in constraints:
                    column_sql += f" CHECK ({col_name} BETWEEN {constraints.min} AND {constraints.max})"
                elif "min" in constraints:
                    column_sql += f" CHECK ({col_name} >= {constraints.min})"
                elif "max" in constraints:
                    column_sql += f" CHECK ({col_name} <= {constraints.max})"

                column_definitions.append(column_sql)

            # Final CREATE query
            create_query = sql.SQL("""
                CREATE TABLE IF NOT EXISTS {} (
                    {}
                );
            """).format(
                sql.Identifier(table_name),
                sql.SQL(", ").join(map(sql.SQL, column_definitions))
            )
            logger.info(f"Executing query: {create_query.as_string(self._connection)}")
            self._cursor.execute(create_query)
            self._connection.commit()
            logger.info(f"Table '{table_name}' created.")

        except Exception as e:
            msg = f"Failed to create table: '{table_name}'"
            raise StudentPerformanceError(e, msg) from e
        logger.info(f"Finished creating table from schema: {self.postgres_config.table_name}")

    def insert_data_from_csv(self) -> None:
        """
        Insert data from the configured CSV file into the PostgreSQL table.

        Raises:
            StudentPerformanceError: If data insertion fails.
        """
        logger.info(f"Inserting data from CSV into table: {self.postgres_config.table_name}")
        try:
            self._connect()
            
            # Read the CSV file into a Pandas DataFrame
            csv_filepath = self.postgres_config.input_data_filepath
            logger.info(f"Reading CSV file: {csv_filepath}")
            df = pd.read_csv(csv_filepath)
            
            # Get the table name
            table_name = self.postgres_config.table_name
            
            # Define the SQL INSERT query
            columns = ', '.join(df.columns)
            values = ', '.join(['%s'] * len(df.columns))
            insert_query = sql.SQL("INSERT INTO {} ({}) VALUES ({})").format(
                sql.Identifier(table_name),
                sql.SQL(columns),
                sql.SQL(values)
            )
            
            # Execute the INSERT query for each row in the DataFrame
            logger.info("Inserting data into table")
            for _, row in df.iterrows():
                self._cursor.execute(insert_query, row.tolist())
            
            # Commit the changes to the database
            self._connection.commit()
            
        except Exception as e:
            msg = f"Failed to insert data from CSV into table: {self.postgres_config.table_name}"
            raise StudentPerformanceError(e, msg) from e
        logger.info(f"Successfully inserted data from CSV into table: {self.postgres_config.table_name}")
        logger.info(f"Finished inserting data from CSV into table: {self.postgres_config.table_name}")

    def read_data_to_df(self) -> pd.DataFrame:
        """
        Reads data from the PostgreSQL table into a Pandas DataFrame.

        Returns:
            pd.DataFrame: A Pandas DataFrame containing the data from the table.

        Raises:
            StudentPerformanceError: If reading data fails.
        """
        logger.info(f"Reading data from PostgreSQL table: {self.postgres_config.table_name}")
        try:
            self._connect()
            query = sql.SQL("SELECT * FROM {}").format(sql.Identifier(self.postgres_config.table_name))
            logger.info(f"Executing query: {query.as_string(self._connection)}")
            df = pd.read_sql_query(query.as_string(self._connection), self._connection)
            logger.info(f"Successfully read data from PostgreSQL table: {self.postgres_config.table_name}")
            logger.info(f"Finished reading data from PostgreSQL table: {self.postgres_config.table_name}")
            return df
        except Exception as e:
            msg = f"Failed to read data from PostgreSQL table: {self.postgres_config.table_name}"
            raise StudentPerformanceError(e, msg) from e

================================================================================
# PY FILE: src\student_performance\entity\__init__.py
================================================================================



================================================================================
# PY FILE: src\student_performance\entity\artifact_entity.py
================================================================================

from box import ConfigBox
from dataclasses import dataclass
from pathlib import Path

@dataclass(frozen=True)
class DataIngestionArtifact:
    raw_artifact_path: Path
    ingested_data_filepath: Path
    dvc_raw_filepath: Path

    def __repr__(self) -> str:
        raw_artifact_str = self.raw_artifact_path.as_posix() if self.raw_artifact_path else "None"
        raw_dvc_str = self.dvc_raw_filepath.as_posix() if self.dvc_raw_filepath else "None"
        ingested_data_str = self.ingested_data_filepath.as_posix() if self.ingested_data_filepath else "None"

        return (
            "\nData Ingestion Artifact:\n"
            f"  - Raw Artifact:         '{raw_artifact_str}'\n"
            f"  - Raw DVC Path:         '{raw_dvc_str}'\n"
            f"  - Ingested Data Path:   '{ingested_data_str}'\n"
        )

@dataclass(frozen=True)
class DataValidationArtifact:
    validated_filepath: Path
    validation_status: bool

    def __repr__(self) -> str:
        validated_str = self.validated_filepath.as_posix() if self.validated_filepath else "None"

        return (
            "\nData Validation Artifact:\n"
            f"  - Validated Data Path: '{validated_str}'\n"
            f"  - Validation Status:   '{self.validation_status}'\n"
        )


@dataclass(frozen=True)
class DataTransformationArtifact:
    x_train_filepath: Path
    y_train_filepath: Path
    x_val_filepath: Path
    y_val_filepath: Path
    x_test_filepath: Path
    y_test_filepath: Path
    x_preprocessor_filepath: Path
    y_preprocessor_filepath: Path

    def __repr__(self) -> str:
        return (
            "\nData Transformation Artifact:\n"
            f"  - X Train Path:         '{self.x_train_filepath.as_posix()}'\n"
            f"  - Y Train Path:         '{self.y_train_filepath.as_posix()}'\n"
            f"  - X Val Path:           '{self.x_val_filepath.as_posix()}'\n"
            f"  - Y Val Path:           '{self.y_val_filepath.as_posix()}'\n"
            f"  - X Test Path:          '{self.x_test_filepath.as_posix()}'\n"
            f"  - Y Test Path:          '{self.y_test_filepath.as_posix()}'\n"
            f"  - X Preprocessor Path:  '{self.x_preprocessor_filepath.as_posix()}'\n"
            f"  - Y Preprocessor Path:  '{self.y_preprocessor_filepath.as_posix()}'\n"
        )

================================================================================
# PY FILE: src\student_performance\entity\config_entity.py
================================================================================

from box import ConfigBox
from dataclasses import dataclass
from pathlib import Path


@dataclass
class PostgresDBHandlerConfig:
    root_dir: Path
    host: str
    port: int
    dbname: str
    user: str
    password: str
    table_name: str
    input_data_filepath: Path
    table_schema: ConfigBox

    def __post_init__(self):
        self.root_dir = Path(self.root_dir)
        self.input_data_filepath = Path(self.input_data_filepath)

    def __repr__(self) -> str:
        return (
            "\nPostgres DB Handler Config:\n"
            f"  - Root Dir:         '{self.root_dir.as_posix()}'\n"
            f"  - Host:             {self.host}\n"
            f"  - Port:             {self.port}\n"
            f"  - Database Name:    {self.dbname}\n"
            f"  - User:             {self.user}\n"
            f"  - Password:         {'*' * 8} (hidden)\n"
            f"  - Table:            {self.table_name}\n"
            f"  - Input Filepath:   '{self.input_data_filepath.as_posix()}'\n"
            f"  - Input Filepath:   {'table_schema'} (hidden)\n"
        )


@dataclass
class DataIngestionConfig:
    root_dir: Path
    raw_data_filepath: Path
    dvc_raw_filepath: Path
    ingested_data_filepath: Path

    def __post_init__(self):
        self.root_dir = Path(self.root_dir)
        self.raw_data_filepath = Path(self.raw_data_filepath)
        self.dvc_raw_filepath = Path(self.dvc_raw_filepath)
        self.ingested_data_filepath = Path(self.ingested_data_filepath)

    def __repr__(self) -> str:
        return (
            "\nData Ingestion Config:\n"
            f"  - Root Dir:           '{self.root_dir.as_posix()}'\n"
            f"  - Raw Data Path:      '{self.raw_data_filepath.as_posix()}'\n"
            f"  - DVC Raw Path:       '{self.dvc_raw_filepath.as_posix()}'\n"
            f"  - Ingested Data Path: '{self.ingested_data_filepath.as_posix()}'\n"
        )


@dataclass
class DataValidationConfig:
    root_dir: Path
    validated_filepath: Path
    dvc_validated_filepath: Path

    schema: ConfigBox
    report_template: ConfigBox
    validation_params: ConfigBox

    missing_report_filepath: Path
    duplicates_report_filepath: Path
    drift_report_filepath: Path
    validation_report_filepath: Path
    categorical_report_filepath: Path

    def __post_init__(self):
        self.root_dir = Path(self.root_dir)
        self.validated_filepath = Path(self.validated_filepath)
        self.dvc_validated_filepath = Path(self.dvc_validated_filepath)

        self.missing_report_filepath = Path(self.missing_report_filepath)
        self.duplicates_report_filepath = Path(self.duplicates_report_filepath)
        self.drift_report_filepath = Path(self.drift_report_filepath)
        self.validation_report_filepath = Path(self.validation_report_filepath)
        self.categorical_report_filepath = Path(self.categorical_report_filepath)

    def __repr__(self) -> str:
        return (
            "\nData Validation Config:\n"
            f"  - Root Dir:                '{self.root_dir.as_posix()}'\n"
            f"  - Validated CSV:           '{self.validated_filepath.as_posix()}'\n"
            f"  - DVC Validated Path:      '{self.dvc_validated_filepath.as_posix()}'\n"
            f"  - Missing Report:          '{self.missing_report_filepath.as_posix()}'\n"
            f"  - Duplicates Report:       '{self.duplicates_report_filepath.as_posix()}'\n"
            f"  - Drift Report:            '{self.drift_report_filepath.as_posix()}'\n"
            f"  - Categorical Report:      '{self.categorical_report_filepath.as_posix()}'\n"
            f"  - Validation Report:       '{self.validation_report_filepath.as_posix()}'\n"
            f"  - Schema Config:           'schema' (hidden)\n"
            f"  - Report Template:         'template' (hidden)\n"
            f"  - Validation Params:       'params' (hidden)\n"
        )


@dataclass
class DataTransformationConfig:
    root_dir: Path

    # Target and parameters
    target_column: str
    transformation_params: ConfigBox

    # Transformed dataset filepaths
    x_train_filepath: Path
    y_train_filepath: Path
    x_val_filepath: Path
    y_val_filepath: Path
    x_test_filepath: Path
    y_test_filepath: Path

    # DVC-tracked filepaths
    x_train_dvc_filepath: Path
    y_train_dvc_filepath: Path
    x_val_dvc_filepath: Path
    y_val_dvc_filepath: Path
    x_test_dvc_filepath: Path
    y_test_dvc_filepath: Path

    # Preprocessor objects
    x_preprocessor_filepath: Path
    y_preprocessor_filepath: Path

    def __post_init__(self):
        self.root_dir = Path(self.root_dir)
        self.x_train_filepath = Path(self.x_train_filepath)
        self.y_train_filepath = Path(self.y_train_filepath)
        self.x_val_filepath = Path(self.x_val_filepath)
        self.y_val_filepath = Path(self.y_val_filepath)
        self.x_test_filepath = Path(self.x_test_filepath)
        self.y_test_filepath = Path(self.y_test_filepath)

        self.x_train_dvc_filepath = Path(self.x_train_dvc_filepath)
        self.y_train_dvc_filepath = Path(self.y_train_dvc_filepath)
        self.x_val_dvc_filepath = Path(self.x_val_dvc_filepath)
        self.y_val_dvc_filepath = Path(self.y_val_dvc_filepath)
        self.x_test_dvc_filepath = Path(self.x_test_dvc_filepath)
        self.y_test_dvc_filepath = Path(self.y_test_dvc_filepath)

        self.x_preprocessor_filepath = Path(self.x_preprocessor_filepath)
        self.y_preprocessor_filepath = Path(self.y_preprocessor_filepath)

    def __repr__(self) -> str:
        return (
            "\nData Transformation Config:\n"
            f"  - Root Dir:              '{self.root_dir.as_posix()}'\n"
            f"  - Target Column:         '{self.target_column}'\n"
            f"  - X Train:               '{self.x_train_filepath.as_posix()}'\n"
            f"  - Y Train:               '{self.y_train_filepath.as_posix()}'\n"
            f"  - X Val:                 '{self.x_val_filepath.as_posix()}'\n"
            f"  - Y Val:                 '{self.y_val_filepath.as_posix()}'\n"
            f"  - X Test:                '{self.x_test_filepath.as_posix()}'\n"
            f"  - Y Test:                '{self.y_test_filepath.as_posix()}'\n"
            f"  - X Preprocessor:        '{self.x_preprocessor_filepath.as_posix()}'\n"
            f"  - Y Preprocessor:        '{self.y_preprocessor_filepath.as_posix()}'\n"
            f"  - Transformation Params: 'transformation_params' (hidden)\n"
        )

================================================================================
# PY FILE: src\student_performance\exception\__init__.py
================================================================================


